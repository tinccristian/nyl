#pragma once

#include <unordered_map>
#include <typeindex>
#include <memory>
#include <queue>
#include "core.h"
#include "log.h"

class Component;

/**
 * @class Entity
 * @brief This class represents an entity in an Entity-Component-System (ECS) architecture.
 * 
 * Each entity has a unique ID and can have multiple components of different types.
 * The Entity class provides methods to add, retrieve, check for existence, and remove components.
 * 
 * This class is part of the NYL engine and is exported as a DLL.
 */
class NYL_API Entity {
public:
    /**
     * @brief Construct a new Entity object with a unique ID.
     * 
     * If there are any free IDs, one is taken from the pool and used as the ID for this entity.
     * If there are no free IDs, a new ID is generated by incrementing a static counter.
     */
    Entity() {
        if (!freeIds.empty()) {
            id = freeIds.front();
            freeIds.pop();
        } else {
            id = nextId++;
        }
    }

    /**
     * @brief Destroy the Entity object and return its ID to the pool of free IDs.
     */
    ~Entity() {
        freeIds.push(id);
    }

    /**
     * @brief Add a component of type T to this entity.
     * 
     * This method takes any number of arguments, which are forwarded to the constructor of the component.
     * 
     * @tparam T The type of the component to add.
     * @tparam Args The types of the arguments to forward to the constructor of the component.
     * @param args The arguments to forward to the constructor of the component.
     */
    template <typename T, typename... Args>
    void addComponent(Args&&... args) {
        auto type = std::type_index(typeid(T));
        if (components.count(type) > 0) {
            NYL_CORE_ERROR("Component of type {0} already exists", typeid(T).name());
            return;
        }
        components[type] = std::make_shared<T>(std::forward<Args>(args)...);
    }

    /**
     * @brief Get the component of type T from this entity.
     * 
     * If the entity does not have a component of type T, this method returns a null pointer.
     * 
     * @tparam T The type of the component to get.
     * @return T* A pointer to the component of type T, or a null pointer if the entity does not have a component of type T.
     */
    template <typename T>
    std::shared_ptr<T> getComponent() const {
        auto iter = components.find(std::type_index(typeid(T)));
        if (iter == components.end()) {
            NYL_CORE_ERROR("Component of type {0} does not exist", typeid(T).name());
            return nullptr;
        }
        return std::static_pointer_cast<T>(iter->second);
    }

    /**
     * @brief Check if this entity has a component of type T.
     * 
     * @tparam T The type of the component to check for.
     * @return true If the entity has a component of type T.
     * @return false Otherwise.
     */
    template <typename T>
    bool hasComponent() const {
        return components.count(std::type_index(typeid(T))) > 0;
    }

    /**
     * @brief Remove the component of type T from this entity.
     * 
     * If the entity does not have a component of type T, this method does nothing.
     * 
     * @tparam T The type of the component to remove.
     */
    template <typename T>
    void removeComponent() {
        auto type = std::type_index(typeid(T));
        if (components.count(type) == 0) {
            NYL_CORE_ERROR("Component of type {0} does not exist", typeid(T).name());
            return;
        }
        components.erase(type);
    }

private:
    int id; ///< The unique ID for this entity.
    static int nextId; ///< The next ID to use if there are no free IDs
    static std::queue<int> freeIds; ///< The pool of free IDs.
    std::unordered_map<std::type_index, std::shared_ptr<Component>> components; ///< The components of this entity, mapped by their type index.
};